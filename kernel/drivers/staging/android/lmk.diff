21d20
<  * Copyright (C) 2012 Sony Mobile Communications AB.
38a38
> #include <linux/swap.h>
41,42d40
< #include <linux/ktime.h>
< #include <linux/spinlock.h>
60,62c58
< static ktime_t lowmem_deathpending_timeout;
< 
< #define LMK_BUSY (-1)
---
> static unsigned long lowmem_deathpending_timeout;
72d67
< 	static DEFINE_SPINLOCK(lowmem_lock);
76,81d70
< 	static int same_count;
< 	static int busy_count;
< 	static int busy_count_dropped;
< 	static int oldpid;
< 	static int lastpid;
< 	static ktime_t next_busy_print;
88c77
< 	int other_free = global_page_state(NR_FREE_PAGES);
---
> 	int other_free = global_page_state(NR_FREE_PAGES) - totalreserve_pages;
90c79
< 						global_page_state(NR_FILE_MAPPED);
---
> 						global_page_state(NR_SHMEM);
97,103c86,87
< 		/*
< 		 * Convert lowmem_minfree[i] to signed to avoid that other_free
< 		 * and/or other_file are converted to unsigned.
< 		 *
< 		 */
< 		if (other_free < (int) lowmem_minfree[i] &&
< 		    other_file < (int) lowmem_minfree[i]) {
---
> 		if (other_free < lowmem_minfree[i] &&
> 		    other_file < lowmem_minfree[i]) {
109c93
< 		lowmem_print(3, "lowmem_shrink %lu, %x, ofree %d %d (%lu %lu), ma %d\n",
---
> 		lowmem_print(3, "lowmem_shrink %lu, %x, ofree %d %d, ma %d\n",
111,114c95
< 				other_file,
< 				global_page_state(NR_FILE_PAGES),
< 				global_page_state(NR_FILE_MAPPED),
< 				min_score_adj);
---
> 				other_file, min_score_adj);
126,139d106
< 	if (spin_trylock(&lowmem_lock) == 0) {
< 		if (ktime_us_delta(ktime_get(), next_busy_print) > 0) {
< 			lowmem_print(2, "Lowmemkiller busy %d %d %d\n",
< 				busy_count, busy_count_dropped,
< 				oom_killer_disabled);
< 			next_busy_print = ktime_add(ktime_get(),
< 						    ktime_set(5, 0));
< 			busy_count_dropped = 0;
< 		}
< 		busy_count++;
< 		busy_count_dropped++;
< 		return LMK_BUSY;
< 	}
< 	/* turn of scheduling to protect task list */
153,154c120
< 			ktime_us_delta(ktime_get(),
< 				lowmem_deathpending_timeout) < 0) {
---
> 		    time_before_eq(jiffies, lowmem_deathpending_timeout)) {
156,171d121
< 			same_count++;
< 			if (p->pid != oldpid || same_count > 1000) {
< 				lowmem_print(1,
< 					"terminate %d (%s) old:%d last:%d %ld %d\n",
< 					p->pid, p->comm, oldpid, lastpid,
< 					(long)ktime_us_delta(ktime_get(),
< 						lowmem_deathpending_timeout),
< 					same_count);
< 				lowmem_print(2,
< 					"state:%ld flag:0x%x la:%lld busy:%d %d\n",
< 					p->state, p->flags,
< 					p->sched_info.last_arrival,
< 					busy_count, oom_killer_disabled);
< 				oldpid = p->pid;
< 				same_count = 0;
< 			}
173,176c123
< 			spin_unlock(&lowmem_lock);
< 			/* wait one jiffie */
< 			schedule_timeout(1);
< 			return LMK_BUSY;
---
> 			return 0;
197c144
< 		lowmem_print(4, "select %d (%s), adj %d, size %d, to kill\n",
---
> 		lowmem_print(2, "select %d (%s), adj %d, size %d, to kill\n",
203a151
> 		lowmem_deathpending_timeout = jiffies + HZ;
205,212d152
< 
< 		lowmem_deathpending_timeout = ktime_add_ns(ktime_get(),
< 							   NSEC_PER_SEC/2);
< 		lowmem_print(2, "state:%ld flag:0x%x la:%lld busy:%d %d\n",
< 			     selected->state, selected->flags,
< 			     selected->sched_info.last_arrival,
< 			     busy_count, oom_killer_disabled);
< 		lastpid = selected->pid;
219d158
< 	spin_unlock(&lowmem_lock);
238a178,254
> #ifdef CONFIG_ANDROID_LOW_MEMORY_KILLER_AUTODETECT_OOM_ADJ_VALUES
> static int lowmem_oom_adj_to_oom_score_adj(int oom_adj)
> {
> 	if (oom_adj == OOM_ADJUST_MAX)
> 		return OOM_SCORE_ADJ_MAX;
> 	else
> 		return (oom_adj * OOM_SCORE_ADJ_MAX) / -OOM_DISABLE;
> }
> 
> static void lowmem_autodetect_oom_adj_values(void)
> {
> 	int i;
> 	int oom_adj;
> 	int oom_score_adj;
> 	int array_size = ARRAY_SIZE(lowmem_adj);
> 
> 	if (lowmem_adj_size < array_size)
> 		array_size = lowmem_adj_size;
> 
> 	if (array_size <= 0)
> 		return;
> 
> 	oom_adj = lowmem_adj[array_size - 1];
> 	if (oom_adj > OOM_ADJUST_MAX)
> 		return;
> 
> 	oom_score_adj = lowmem_oom_adj_to_oom_score_adj(oom_adj);
> 	if (oom_score_adj <= OOM_ADJUST_MAX)
> 		return;
> 
> 	lowmem_print(1, "lowmem_shrink: convert oom_adj to oom_score_adj:\n");
> 	for (i = 0; i < array_size; i++) {
> 		oom_adj = lowmem_adj[i];
> 		oom_score_adj = lowmem_oom_adj_to_oom_score_adj(oom_adj);
> 		lowmem_adj[i] = oom_score_adj;
> 		lowmem_print(1, "oom_adj %d => oom_score_adj %d\n",
> 			     oom_adj, oom_score_adj);
> 	}
> }
> 
> static int lowmem_adj_array_set(const char *val, const struct kernel_param *kp)
> {
> 	int ret;
> 
> 	ret = param_array_ops.set(val, kp);
> 
> 	/* HACK: Autodetect oom_adj values in lowmem_adj array */
> 	lowmem_autodetect_oom_adj_values();
> 
> 	return ret;
> }
> 
> static int lowmem_adj_array_get(char *buffer, const struct kernel_param *kp)
> {
> 	return param_array_ops.get(buffer, kp);
> }
> 
> static void lowmem_adj_array_free(void *arg)
> {
> 	param_array_ops.free(arg);
> }
> 
> static struct kernel_param_ops lowmem_adj_array_ops = {
> 	.set = lowmem_adj_array_set,
> 	.get = lowmem_adj_array_get,
> 	.free = lowmem_adj_array_free,
> };
> 
> static const struct kparam_array __param_arr_adj = {
> 	.max = ARRAY_SIZE(lowmem_adj),
> 	.num = &lowmem_adj_size,
> 	.ops = &param_ops_int,
> 	.elemsize = sizeof(lowmem_adj[0]),
> 	.elem = lowmem_adj,
> };
> #endif
> 
239a256,262
> #ifdef CONFIG_ANDROID_LOW_MEMORY_KILLER_AUTODETECT_OOM_ADJ_VALUES
> __module_param_call(MODULE_PARAM_PREFIX, adj,
> 		    &lowmem_adj_array_ops,
> 		    .arr = &__param_arr_adj,
> 		    S_IRUGO | S_IWUSR, 0);
> __MODULE_PARM_TYPE(adj, "array of int");
> #else
241a265
> #endif
